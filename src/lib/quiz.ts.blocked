import type {
  Fish,
  QuizQuestion,
  IdentifyQuestion,
  FeatureQuestion,
  TrueFalseQuestion,
  MatchQuestion,
  SpotQuestion,
} from '@/types';
import { FISH } from '@/fish';
import { SIMILAR_PAIRS } from '@/data/similarPairs';
import { shuffle } from '@/lib/utils';

// Helper: Get all fish as array
function getAllFish(): Fish[] {
  return Object.values(FISH);
}

// Helper: Get random fish from pool (excluding already used)
function getRandomFish(pool: Fish[], exclude: Set<string> = new Set()): Fish {
  const available = pool.filter((f) => !exclude.has(f.id));
  if (available.length === 0) {
    // If all fish used, allow reuse but prefer less-used ones
    return pool[Math.floor(Math.random() * pool.length)];
  }
  return available[Math.floor(Math.random() * available.length)];
}

/**
 * Generator 1: Identify Question
 * Shows fish image, user picks correct name from 4 options
 */
function qIdentify(fishPool: Fish[], usedFish: Set<string>): IdentifyQuestion {
  const fish = getRandomFish(fishPool, usedFish);
  usedFish.add(fish.id);

  // Get 3 wrong answer options from other fish
  const wrongOptions = shuffle(fishPool.filter((f) => f.id !== fish.id))
    .slice(0, 3)
    .map((f) => f.name);

  const options = shuffle([fish.name, ...wrongOptions]);

  return {
    type: 'identify',
    fishId: fish.id,
    image: fish.quizImage,
    options,
    correct: fish.name,
  };
}

/**
 * Generator 2: Feature Question
 * Shows fish, user picks the key identifying feature from 4 options
 */
function qFeature(fishPool: Fish[], usedFish: Set<string>): FeatureQuestion {
  const fish = getRandomFish(fishPool, usedFish);
  usedFish.add(fish.id);

  // Use the fish's feature options (1 correct, 3 wrong)
  const wrongOptions = fish.featureOptions.wrong.slice(0, 3);
  const options = shuffle([fish.featureOptions.correct, ...wrongOptions]);

  return {
    type: 'feature',
    fishId: fish.id,
    image: fish.quizImage,
    options,
    correct: fish.featureOptions.correct,
  };
}

/**
 * Generator 3: True/False Question
 * Shows a statement about a fish, user says true or false
 */
function qTrueFalse(fishPool: Fish[], usedStatements: Set<string>): TrueFalseQuestion {
  // Collect all available T/F statements from fish pool
  const allStatements = fishPool.flatMap((f) =>
    f.trueFalseQuestions.map((q) => ({ ...q, fishId: f.id }))
  );

  // Filter to unused statements
  const available = allStatements.filter((s) => !usedStatements.has(s.statement));

  // If all used, pick from all (allow repeats)
  const pool = available.length > 0 ? available : allStatements;
  const chosen = pool[Math.floor(Math.random() * pool.length)];

  usedStatements.add(chosen.statement);

  return {
    type: 'tf',
    fishId: chosen.fishId,
    statement: chosen.statement,
    correct: chosen.answer,
  };
}

/**
 * Generator 4: Match Question
 * Match 3 fish names to their key features
 */
function qMatch(fishPool: Fish[]): MatchQuestion {
  // Pick 3 random fish from pool
  const selectedFish = shuffle(fishPool).slice(0, 3);

  // Create pairs of names and features
  const pairs = selectedFish.map((f) => ({
    left: f.name,
    right: f.keyFeature,
    fishId: f.id,
  }));

  // Shuffle the rights independently to create puzzle
  const shuffledRights = shuffle(pairs.map((p) => p.right));

  return {
    type: 'match',
    pairs: pairs.map((p, i) => ({
      left: p.left,
      right: shuffledRights[i],
      fishId: p.fishId,
    })),
  };
}

/**
 * Generator 5: Spot Difference Question
 * Show two similar fish images, user picks the correct one
 */
function qSpotDifference(fishPool: Fish[]): SpotQuestion {
  // Pick a random similar pair
  const pair = SIMILAR_PAIRS[Math.floor(Math.random() * SIMILAR_PAIRS.length)];
  const fish1 = FISH[pair.fish1];
  const fish2 = FISH[pair.fish2];

  // Randomly decide which fish to ask about
  const askAbout = Math.random() < 0.5 ? fish1 : fish2;
  const options = shuffle([fish1.name, fish2.name]);

  return {
    type: 'spot',
    fish1Id: fish1.id,
    fish2Id: fish2.id,
    image1: fish1.quizImage,
    image2: fish2.quizImage,
    question: `Which is ${askAbout.name}?`,
    options,
    correct: askAbout.name,
    hint: pair.hint,
  };
}

/**
 * Main Quiz Builder Function
 * Generates a mixed quiz of specified length from fish pool
 */
export function buildQuizQuestions(fishPool: Fish[], count: number): QuizQuestion[] {
  const questions: QuizQuestion[] = [];
  const usedFish = new Set<string>();
  const usedStatements = new Set<string>();

  // Calculate distribution of question types (percentages)
  const distribution = {
    identify: Math.ceil(count * 0.3), // 30% identify questions
    feature: Math.ceil(count * 0.2), // 20% feature questions
    tf: Math.ceil(count * 0.2), // 20% true/false questions
    match: Math.ceil(count * 0.2), // 20% match questions
    spot: Math.ceil(count * 0.1), // 10% spot difference questions
  };

  // Generate questions by type
  for (let i = 0; i < distribution.identify && questions.length < count; i++) {
    questions.push(qIdentify(fishPool, usedFish));
  }

  for (let i = 0; i < distribution.feature && questions.length < count; i++) {
    questions.push(qFeature(fishPool, usedFish));
  }

  for (let i = 0; i < distribution.tf && questions.length < count; i++) {
    questions.push(qTrueFalse(fishPool, usedStatements));
  }

  for (let i = 0; i < distribution.match && questions.length < count; i++) {
    questions.push(qMatch(fishPool));
  }

  for (let i = 0; i < distribution.spot && questions.length < count; i++) {
    questions.push(qSpotDifference(fishPool));
  }

  // Trim to exact count and shuffle order
  return shuffle(questions.slice(0, count));
}

// Export helper to get fish by lesson
export function getFishByLesson(lessonId: number): Fish[] {
  // This will be implemented when lessons data is integrated
  return getAllFish();
}

// Export all fish helper
export { getAllFish };
